# Testing Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add Vitest unit tests for all 10 MCP tools and an integration smoke test, by first extracting handlers into testable modules.

**Architecture:** Split `src/index.ts` into `src/auth.ts` (token fetch), `src/tools.ts` (all 10 handler functions), and a thin `src/index.ts` (MCP wiring only). Tests import handlers directly and mock `fetch` + `getPluggyAccessToken` with `vi.stubGlobal` / `vi.mock`.

**Tech Stack:** Vitest, TypeScript, Node.js ESM (`"type": "module"`)

---

### Task 1: Install Vitest and configure scripts

**Files:**
- Modify: `package.json`
- Modify: `tsconfig.json`

**Step 1: Install vitest**

```bash
npm install --save-dev vitest
```

Expected: vitest appears in `devDependencies` in `package.json`.

**Step 2: Add test scripts to package.json**

In the `"scripts"` section, add:

```json
"test": "vitest run",
"test:unit": "vitest run src/tests/unit",
"test:integration": "vitest run src/tests/integration",
"test:watch": "vitest"
```

**Step 3: Exclude test files from TypeScript build**

In `tsconfig.json`, update `"exclude"` so test files don't compile into `dist/`:

```json
"exclude": ["node_modules", "src/tests"]
```

**Step 4: Verify**

```bash
npm run build
```

Expected: exits 0, no change in `dist/`.

**Step 5: Commit**

```bash
git add package.json package-lock.json tsconfig.json
git commit -m "chore: install vitest and add test scripts"
```

---

### Task 2: Extract `src/auth.ts` — TDD

**Files:**
- Create: `src/tests/unit/auth.test.ts`
- Create: `src/auth.ts`

**Step 1: Write the failing test**

Create `src/tests/unit/auth.test.ts`:

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';
import { getPluggyAccessToken } from '../../auth.js';

afterEach(() => { vi.unstubAllGlobals(); });

describe('getPluggyAccessToken', () => {
  it('POSTs credentials to /auth and returns the apiKey', async () => {
    process.env.PLUGGY_CLIENT_ID = 'test-id';
    process.env.PLUGGY_CLIENT_SECRET = 'test-secret';

    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      json: async () => ({ apiKey: 'my-api-key' }),
    }));

    const token = await getPluggyAccessToken();

    expect(token).toBe('my-api-key');
    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/auth',
      expect.objectContaining({
        method: 'POST',
        body: JSON.stringify({ clientId: 'test-id', clientSecret: 'test-secret' }),
      })
    );
  });
});
```

**Step 2: Run test — verify it fails**

```bash
npm run test:unit
```

Expected: FAIL — `Cannot find module '../../auth.js'`

**Step 3: Create `src/auth.ts`**

```typescript
export async function getPluggyAccessToken(): Promise<string> {
  const authResponse = await fetch('https://api.pluggy.ai/auth', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      clientId: process.env.PLUGGY_CLIENT_ID,
      clientSecret: process.env.PLUGGY_CLIENT_SECRET,
    }),
  });
  const authJson = await authResponse.json();
  return authJson.apiKey;
}
```

**Step 4: Run test — verify it passes**

```bash
npm run test:unit
```

Expected: PASS — `getPluggyAccessToken > POSTs credentials to /auth and returns the apiKey`

**Step 5: Commit**

```bash
git add src/auth.ts src/tests/unit/auth.test.ts
git commit -m "feat: extract auth.ts with test"
```

---

### Task 3: Write failing unit tests for all 10 tool handlers

All these tests will fail with `Cannot find module '../../tools.js'` — that's correct (RED).

**Files:**
- Create: `src/tests/unit/getAccounts.test.ts`
- Create: `src/tests/unit/listConnectors.test.ts`
- Create: `src/tests/unit/listItems.test.ts`
- Create: `src/tests/unit/getItem.test.ts`
- Create: `src/tests/unit/getInvestments.test.ts`
- Create: `src/tests/unit/getLoans.test.ts`
- Create: `src/tests/unit/getCreditCardBills.test.ts`
- Create: `src/tests/unit/getIdentity.test.ts`

**Step 1: Create `src/tests/unit/getAccounts.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleGetAccounts', () => {
  it('fetches /accounts with itemId and auth header', async () => {
    const { handleGetAccounts } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ results: [] }),
    }));

    await handleGetAccounts({ itemId: 'item-abc' });

    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/accounts?itemId=item-abc',
      expect.objectContaining({ headers: { 'X-API-KEY': 'test-token' } })
    );
  });

  it('returns error text on non-ok response', async () => {
    const { handleGetAccounts } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 404, json: async () => ({ message: 'Not found' }),
    }));

    const result = await handleGetAccounts({ itemId: 'bad' });
    expect(result.content[0].text).toContain('Error 404');
    expect(result.content[0].text).toContain('Not found');
  });
});
```

**Step 2: Create `src/tests/unit/listConnectors.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleListConnectors', () => {
  it('fetches /connectors with auth header', async () => {
    const { handleListConnectors } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ results: [] }),
    }));

    await handleListConnectors({});

    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/connectors',
      expect.objectContaining({ headers: { 'X-API-KEY': 'test-token' } })
    );
  });

  it('returns error text on non-ok response', async () => {
    const { handleListConnectors } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 401, json: async () => ({ message: 'Unauthorized' }),
    }));

    const result = await handleListConnectors({});
    expect(result.content[0].text).toContain('Error 401');
  });
});
```

**Step 3: Create `src/tests/unit/listItems.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleListItems', () => {
  it('fetches /items with auth header', async () => {
    const { handleListItems } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ results: [], total: 0 }),
    }));

    await handleListItems({});

    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/items',
      expect.objectContaining({ headers: { 'X-API-KEY': 'test-token' } })
    );
  });

  it('returns error text on non-ok response', async () => {
    const { handleListItems } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 500, json: async () => ({ message: 'Server error' }),
    }));

    const result = await handleListItems({});
    expect(result.content[0].text).toContain('Error 500');
  });
});
```

**Step 4: Create `src/tests/unit/getItem.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleGetItem', () => {
  it('fetches /items/:itemId with auth header', async () => {
    const { handleGetItem } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ id: 'item-xyz', status: 'UPDATED' }),
    }));

    await handleGetItem({ itemId: 'item-xyz' });

    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/items/item-xyz',
      expect.objectContaining({ headers: { 'X-API-KEY': 'test-token' } })
    );
  });

  it('returns error text on non-ok response', async () => {
    const { handleGetItem } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 404, json: async () => ({ message: 'Item not found' }),
    }));

    const result = await handleGetItem({ itemId: 'bad' });
    expect(result.content[0].text).toContain('Error 404');
    expect(result.content[0].text).toContain('Item not found');
  });
});
```

**Step 5: Create `src/tests/unit/getInvestments.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleGetInvestments', () => {
  it('fetches /investments with itemId and auth header', async () => {
    const { handleGetInvestments } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ results: [] }),
    }));

    await handleGetInvestments({ itemId: 'item-123' });

    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/investments?itemId=item-123',
      expect.objectContaining({ headers: { 'X-API-KEY': 'test-token' } })
    );
  });

  it('returns error text on non-ok response', async () => {
    const { handleGetInvestments } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 422, json: async () => ({ message: 'Invalid item' }),
    }));

    const result = await handleGetInvestments({ itemId: 'bad' });
    expect(result.content[0].text).toContain('Error 422');
  });
});
```

**Step 6: Create `src/tests/unit/getLoans.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleGetLoans', () => {
  it('fetches /loans with itemId and auth header', async () => {
    const { handleGetLoans } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ results: [] }),
    }));

    await handleGetLoans({ itemId: 'item-123' });

    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/loans?itemId=item-123',
      expect.objectContaining({ headers: { 'X-API-KEY': 'test-token' } })
    );
  });

  it('returns error text on non-ok response', async () => {
    const { handleGetLoans } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 404, json: async () => ({ message: 'Not found' }),
    }));

    const result = await handleGetLoans({ itemId: 'bad' });
    expect(result.content[0].text).toContain('Error 404');
  });
});
```

**Step 7: Create `src/tests/unit/getCreditCardBills.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleGetCreditCardBills', () => {
  it('fetches /bills with accountId and auth header', async () => {
    const { handleGetCreditCardBills } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ results: [] }),
    }));

    await handleGetCreditCardBills({ accountId: 'acc-999' });

    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/bills?accountId=acc-999',
      expect.objectContaining({ headers: { 'X-API-KEY': 'test-token' } })
    );
  });

  it('returns error text on non-ok response', async () => {
    const { handleGetCreditCardBills } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 404, json: async () => ({ message: 'Account not found' }),
    }));

    const result = await handleGetCreditCardBills({ accountId: 'bad' });
    expect(result.content[0].text).toContain('Error 404');
  });
});
```

**Step 8: Create `src/tests/unit/getIdentity.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleGetIdentity', () => {
  it('fetches /identity with itemId and auth header', async () => {
    const { handleGetIdentity } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ fullName: 'João Silva' }),
    }));

    await handleGetIdentity({ itemId: 'item-123' });

    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/identity?itemId=item-123',
      expect.objectContaining({ headers: { 'X-API-KEY': 'test-token' } })
    );
  });

  it('returns error text on non-ok response', async () => {
    const { handleGetIdentity } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 404, json: async () => ({ message: 'Not found' }),
    }));

    const result = await handleGetIdentity({ itemId: 'bad' });
    expect(result.content[0].text).toContain('Error 404');
  });
});
```

**Step 9: Run all unit tests — verify they all fail**

```bash
npm run test:unit
```

Expected: All FAIL with `Cannot find module '../../tools.js'` (except auth.test.ts which passes).

**Step 10: Commit the failing tests**

```bash
git add src/tests/
git commit -m "test: add failing unit tests for all tool handlers"
```

---

### Task 4: Write failing tests for getTransactions and createPixPayment

These two tools have extra cases worth testing specifically.

**Files:**
- Create: `src/tests/unit/getTransactions.test.ts`
- Create: `src/tests/unit/createPixPayment.test.ts`

**Step 1: Create `src/tests/unit/getTransactions.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleGetTransactions', () => {
  it('fetches /transactions with required accountId', async () => {
    const { handleGetTransactions } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ results: [], total: 0 }),
    }));

    await handleGetTransactions({ accountId: 'acc-123' });

    const url = vi.mocked(fetch).mock.calls[0][0] as string;
    expect(url).toContain('accountId=acc-123');
    expect(url).not.toContain('from=');
    expect(url).not.toContain('to=');
    expect(url).not.toContain('page=');
    expect(url).not.toContain('pageSize=');
  });

  it('includes optional params in URL when provided', async () => {
    const { handleGetTransactions } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ results: [] }),
    }));

    await handleGetTransactions({
      accountId: 'acc-123',
      from: '2024-01-01',
      to: '2024-12-31',
      page: 2,
      pageSize: 50,
    });

    const url = vi.mocked(fetch).mock.calls[0][0] as string;
    expect(url).toContain('from=2024-01-01');
    expect(url).toContain('to=2024-12-31');
    expect(url).toContain('page=2');
    expect(url).toContain('pageSize=50');
  });

  it('returns error text on non-ok response', async () => {
    const { handleGetTransactions } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 400, json: async () => ({ message: 'Bad request' }),
    }));

    const result = await handleGetTransactions({ accountId: 'bad' });
    expect(result.content[0].text).toContain('Error 400');
  });
});
```

**Step 2: Create `src/tests/unit/createPixPayment.test.ts`**

```typescript
import { vi, describe, it, expect, afterEach } from 'vitest';

vi.mock('../../auth.js', () => ({
  getPluggyAccessToken: vi.fn().mockResolvedValue('test-token'),
}));

afterEach(() => { vi.unstubAllGlobals(); });

describe('handleCreatePixPayment', () => {
  it('POSTs to /payments/requests with correct body and headers', async () => {
    const { handleCreatePixPayment } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ id: 'payment-1', status: 'CREATED' }),
    }));

    await handleCreatePixPayment({
      pixKeyType: 'EMAIL',
      pixKey: 'user@example.com',
      amount: 100.50,
    });

    expect(vi.mocked(fetch)).toHaveBeenCalledWith(
      'https://api.pluggy.ai/payments/requests',
      expect.objectContaining({
        method: 'POST',
        headers: expect.objectContaining({
          'X-API-KEY': 'test-token',
          'Content-Type': 'application/json',
        }),
        body: JSON.stringify({
          type: 'PIX',
          pixAlias: { type: 'EMAIL', value: 'user@example.com' },
          amount: 100.50,
        }),
      })
    );
  });

  it('includes description in body when provided', async () => {
    const { handleCreatePixPayment } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ id: 'payment-2' }),
    }));

    await handleCreatePixPayment({
      pixKeyType: 'CPF',
      pixKey: '123.456.789-00',
      amount: 50,
      description: 'Aluguel',
    });

    const body = JSON.parse((vi.mocked(fetch).mock.calls[0][1] as RequestInit).body as string);
    expect(body.description).toBe('Aluguel');
  });

  it('omits description from body when not provided', async () => {
    const { handleCreatePixPayment } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true, json: async () => ({ id: 'payment-3' }),
    }));

    await handleCreatePixPayment({ pixKeyType: 'EVP', pixKey: 'random-key', amount: 10 });

    const body = JSON.parse((vi.mocked(fetch).mock.calls[0][1] as RequestInit).body as string);
    expect(body).not.toHaveProperty('description');
  });

  it('returns error text on non-ok response', async () => {
    const { handleCreatePixPayment } = await import('../../tools.js');
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false, status: 422, json: async () => ({ message: 'Invalid PIX key' }),
    }));

    const result = await handleCreatePixPayment({ pixKeyType: 'CPF', pixKey: 'bad', amount: 10 });
    expect(result.content[0].text).toContain('Error 422');
    expect(result.content[0].text).toContain('Invalid PIX key');
  });
});
```

**Step 3: Run tests — verify all new tests fail**

```bash
npm run test:unit
```

Expected: `getTransactions.test.ts` and `createPixPayment.test.ts` FAIL with `Cannot find module '../../tools.js'`.

**Step 4: Commit**

```bash
git add src/tests/unit/getTransactions.test.ts src/tests/unit/createPixPayment.test.ts
git commit -m "test: add failing tests for getTransactions and createPixPayment"
```

---

### Task 5: Create `src/tools.ts` — make all unit tests GREEN

Extract all 10 handler functions from `src/index.ts` into a new `src/tools.ts`.

**Files:**
- Create: `src/tools.ts`

**Step 1: Create `src/tools.ts`**

```typescript
import { getPluggyAccessToken } from './auth.js';

type ToolResponse = { content: Array<{ type: 'text'; text: string }> };

function okResponse(json: unknown): ToolResponse {
  return { content: [{ type: 'text', text: JSON.stringify(json, null, 2) }] };
}

function errorResponse(status: number, message: string): ToolResponse {
  return { content: [{ type: 'text', text: `Error ${status}: ${message}` }] };
}

function caughtResponse(err: unknown): ToolResponse {
  return { content: [{ type: 'text', text: `Error: ${err}` }] };
}

export async function handleGetAccounts({ itemId }: { itemId: string }): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const response = await fetch(`https://api.pluggy.ai/accounts?itemId=${itemId}`, {
      headers: { 'X-API-KEY': accessToken },
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}

export async function handleListConnectors(_params: Record<string, never>): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const response = await fetch('https://api.pluggy.ai/connectors', {
      headers: { 'X-API-KEY': accessToken },
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}

export async function handleListItems(_params: Record<string, never>): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const response = await fetch('https://api.pluggy.ai/items', {
      headers: { 'X-API-KEY': accessToken },
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}

export async function handleGetItem({ itemId }: { itemId: string }): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const response = await fetch(`https://api.pluggy.ai/items/${itemId}`, {
      headers: { 'X-API-KEY': accessToken },
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}

export async function handleGetTransactions(params: {
  accountId: string;
  from?: string;
  to?: string;
  page?: number;
  pageSize?: number;
}): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const searchParams = new URLSearchParams({ accountId: params.accountId });
    if (params.from) searchParams.set('from', params.from);
    if (params.to) searchParams.set('to', params.to);
    if (params.page) searchParams.set('page', String(params.page));
    if (params.pageSize) searchParams.set('pageSize', String(params.pageSize));
    const response = await fetch(`https://api.pluggy.ai/transactions?${searchParams}`, {
      headers: { 'X-API-KEY': accessToken },
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}

export async function handleGetInvestments({ itemId }: { itemId: string }): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const response = await fetch(`https://api.pluggy.ai/investments?itemId=${itemId}`, {
      headers: { 'X-API-KEY': accessToken },
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}

export async function handleGetLoans({ itemId }: { itemId: string }): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const response = await fetch(`https://api.pluggy.ai/loans?itemId=${itemId}`, {
      headers: { 'X-API-KEY': accessToken },
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}

export async function handleGetCreditCardBills({ accountId }: { accountId: string }): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const response = await fetch(`https://api.pluggy.ai/bills?accountId=${accountId}`, {
      headers: { 'X-API-KEY': accessToken },
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}

export async function handleGetIdentity({ itemId }: { itemId: string }): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const response = await fetch(`https://api.pluggy.ai/identity?itemId=${itemId}`, {
      headers: { 'X-API-KEY': accessToken },
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}

export async function handleCreatePixPayment(params: {
  pixKeyType: 'CPF' | 'CNPJ' | 'EMAIL' | 'PHONE' | 'EVP';
  pixKey: string;
  amount: number;
  description?: string;
}): Promise<ToolResponse> {
  try {
    const accessToken = await getPluggyAccessToken();
    const body: Record<string, unknown> = {
      type: 'PIX',
      pixAlias: { type: params.pixKeyType, value: params.pixKey },
      amount: params.amount,
    };
    if (params.description) body.description = params.description;
    const response = await fetch('https://api.pluggy.ai/payments/requests', {
      method: 'POST',
      headers: {
        'X-API-KEY': accessToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });
    const json = await response.json();
    if (!response.ok) return errorResponse(response.status, json?.message ?? JSON.stringify(json));
    return okResponse(json);
  } catch (err) { return caughtResponse(err); }
}
```

**Step 2: Run unit tests — verify all pass**

```bash
npm run test:unit
```

Expected: All 22 tests PASS across 10 test files.

**Step 3: Commit**

```bash
git add src/tools.ts
git commit -m "feat: extract tool handlers into src/tools.ts"
```

---

### Task 6: Update `src/index.ts` to import from `auth.ts` and `tools.ts`

Replace the inline handler code in `src/index.ts` with imports. `index.ts` becomes wiring-only.

**Files:**
- Modify: `src/index.ts`

**Step 1: Rewrite `src/index.ts`**

Replace the entire file content with:

```typescript
#!/usr/bin/env node

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import 'dotenv/config';
import {
  handleGetAccounts,
  handleListConnectors,
  handleListItems,
  handleGetItem,
  handleGetTransactions,
  handleGetInvestments,
  handleGetLoans,
  handleGetCreditCardBills,
  handleGetIdentity,
  handleCreatePixPayment,
} from './tools.js';

const server = new McpServer({ name: "Pluggy API", version: "1.0.0" });

server.tool("getAccounts",
  { itemId: z.string().describe("The Pluggy item ID to fetch accounts for") },
  handleGetAccounts);

server.tool("listConnectors", {}, handleListConnectors);

server.tool("listItems", {}, handleListItems);

server.tool("getItem",
  { itemId: z.string().describe("The Pluggy item ID") },
  handleGetItem);

server.tool("getTransactions", {
  accountId: z.string().describe("The Pluggy account ID to fetch transactions for"),
  from: z.string().optional().describe("Start date filter in YYYY-MM-DD format (e.g. 2024-01-01)"),
  to: z.string().optional().describe("End date filter in YYYY-MM-DD format (e.g. 2024-12-31)"),
  page: z.number().optional().describe("Page number, 1-based (default: 1)"),
  pageSize: z.number().optional().describe("Results per page, max 500 (default: 20)"),
}, handleGetTransactions);

server.tool("getInvestments",
  { itemId: z.string().describe("The Pluggy item ID to fetch investments for") },
  handleGetInvestments);

server.tool("getLoans",
  { itemId: z.string().describe("The Pluggy item ID to fetch loans for") },
  handleGetLoans);

server.tool("getCreditCardBills",
  { accountId: z.string().describe("The Pluggy account ID for the credit card account") },
  handleGetCreditCardBills);

server.tool("getIdentity",
  { itemId: z.string().describe("The Pluggy item ID to fetch identity data for") },
  handleGetIdentity);

server.tool("createPixPayment", {
  pixKeyType: z.enum(["CPF", "CNPJ", "EMAIL", "PHONE", "EVP"]).describe("The type of the PIX key"),
  pixKey: z.string().describe("The PIX key value (CPF, CNPJ, email, phone, or random EVP key)"),
  amount: z.number().describe("Payment amount in BRL (e.g. 150.00)"),
  description: z.string().optional().describe("Optional payment description visible to recipient"),
}, handleCreatePixPayment);

const transport = new StdioServerTransport();
await server.connect(transport);
```

**Step 2: Build — verify TypeScript compiles cleanly**

```bash
npm run build
```

Expected: exits 0. `dist/index.js`, `dist/auth.js`, `dist/tools.js` all present.

**Step 3: Run all unit tests — still green**

```bash
npm run test:unit
```

Expected: All 22 tests PASS.

**Step 4: Commit**

```bash
git add src/index.ts
git commit -m "refactor: index.ts imports handlers from tools.ts"
```

---

### Task 7: Add integration smoke test

**Files:**
- Create: `src/tests/integration/smoke.test.ts`

**Step 1: Create `src/tests/integration/smoke.test.ts`**

```typescript
import { describe, it, expect } from 'vitest';
import { handleListItems } from '../../tools.js';

const hasCredentials = !!(process.env.PLUGGY_CLIENT_ID && process.env.PLUGGY_CLIENT_SECRET);

describe.skipIf(!hasCredentials)('Pluggy API smoke test (requires real credentials)', () => {
  it('listItems connects to the API and returns a results array', async () => {
    const result = await handleListItems({});
    // If auth failed, the text will start with "Error"
    expect(result.content[0].text).not.toMatch(/^Error/);
    const json = JSON.parse(result.content[0].text);
    expect(json).toHaveProperty('results');
    expect(Array.isArray(json.results)).toBe(true);
  });
});
```

**Step 2: Run integration test — verify it skips without credentials**

```bash
npm run test:integration
```

Expected: 1 test suite, 0 tests run, 1 skipped (no env vars set).

**Step 3: Verify it runs with credentials (if .env is present)**

```bash
npm test
```

Expected: All unit tests pass; integration test skips or passes depending on env.

**Step 4: Commit**

```bash
git add src/tests/integration/smoke.test.ts
git commit -m "test: add integration smoke test for listItems"
```

---

### Task 8: Update CLAUDE.md with test commands

**Files:**
- Modify: `CLAUDE.md`

**Step 1: Add test commands to the Commands section**

In `CLAUDE.md`, update the Commands section to include:

```markdown
npm test                 # Run all tests
npm run test:unit        # Unit tests only (no credentials needed)
npm run test:integration # Integration smoke test (requires .env with real credentials)
npm run test:watch       # Watch mode
```

**Step 2: Add a Testing section after Architecture**

```markdown
## Testing

Tests live in `src/tests/`. Unit tests mock `fetch` and `getPluggyAccessToken` via `vi.mock`/`vi.stubGlobal` — no credentials needed. The integration smoke test hits the real Pluggy sandbox and is skipped automatically when `PLUGGY_CLIENT_ID`/`PLUGGY_CLIENT_SECRET` are absent.

Handler logic lives in `src/tools.ts` (importable, testable). `src/index.ts` is wiring-only (registers tools with the MCP server). `src/auth.ts` exports `getPluggyAccessToken()`.
```

**Step 3: Build + test one last time**

```bash
npm run build && npm test
```

Expected: build exits 0, all tests pass.

**Step 4: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: update CLAUDE.md with test commands and testing section"
```
